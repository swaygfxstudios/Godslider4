<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cinematic Scroll Reveal</title>
<style>
/* Reset and container setup */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html, body {
    width: 100%;
    background: black;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

/* Main cinematic section */
.cinematic-section {
    position: relative;
    width: 100%;
    height: 300vh; /* Triple height to allow for scroll progression */
    background: black;
}

/* Fixed viewport container */
.cinematic-viewport {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    overflow: hidden;
    z-index: 10;
}

/* Image container */
.image-container {
    position: relative;
    width: 100%;
    height: 100%;
}

.image-container img {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center;
    -webkit-user-drag: none;
    user-drag: none;
    -webkit-user-select: none;
    user-select: none;
    pointer-events: none;
}

.after-image {
    clip-path: inset(0 0 0 100%);
    transition: none; /* Smooth scroll-driven animation */
}

/* Progress indicator with yellow gradient */
.progress-bar {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    width: 200px;
    height: 2px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 1px;
    z-index: 20;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #ffe200, #ffb700, #ff8c00);
    border-radius: 1px;
    width: 0%;
    transition: width 0.1s ease-out;
    box-shadow: 0 0 8px rgba(255, 226, 0, 0.4);
}

.cinematic-section.active .progress-bar {
    opacity: 1;
}

/* Smoothly animated text overlay */
.cinematic-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    color: white;
    z-index: 15;
    opacity: 0;
    transition: opacity 0.5s ease;
    will-change: transform, opacity, filter;
}

.cinematic-text p {
    font-size: clamp(0.9rem, 1.8vw, 1.3rem);
    opacity: 0.9;
    text-shadow: 2px 2px 8px rgba(0,0,0,0.8);
    font-weight: 300;
    letter-spacing: 0.5px;
    transform: scale(1);
    filter: blur(0px);
    transition: none; /* We'll handle this with direct style updates */
}

.cinematic-section.active .cinematic-text {
    opacity: 1;
}

/* Scroll hint */
.scroll-hint {
    position: fixed;
    bottom: 20px;
    right: 30px;
    color: white;
    font-size: 14px;
    opacity: 0.8;
    z-index: 20;
    display: flex;
    align-items: center;
    gap: 10px;
    transition: opacity 0.3s ease;
}

.scroll-hint.fade-out {
    opacity: 0;
}

.scroll-arrow {
    width: 20px;
    height: 20px;
    border-right: 2px solid white;
    border-bottom: 2px solid white;
    transform: rotate(45deg);
    animation: bounce 2s infinite;
}

@keyframes bounce {
    0%, 20%, 50%, 80%, 100% {
        transform: rotate(45deg) translateY(0);
    }
    40% {
        transform: rotate(45deg) translateY(-5px);
    }
    60% {
        transform: rotate(45deg) translateY(-3px);
    }
}

/* Loading state */
.loading {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 16px;
    opacity: 0.7;
    z-index: 25;
}

/* Mobile optimizations */
@media (max-width: 768px) {
    .cinematic-section {
        height: 250vh; /* Shorter on mobile */
    }
    
    .progress-bar {
        width: 150px;
        bottom: 20px;
    }
    
    .scroll-hint {
        bottom: 15px;
        right: 20px;
        font-size: 12px;
    }
    
    .cinematic-text p {
        font-size: 1rem;
    }
}

@media (max-width: 480px) {
    .cinematic-section {
        height: 200vh;
    }
    
    .cinematic-text p {
        font-size: 0.9rem;
    }
}

/* Smooth scrolling for the page */
html {
    scroll-behavior: smooth;
}

/* Content after cinematic section */
.content-after {
    background: white;
    min-height: 100vh;
    padding: 4rem 2rem;
    position: relative;
    z-index: 5;
}

.content-after h3 {
    font-size: 2rem;
    margin-bottom: 1rem;
    text-align: center;
}

.content-after p {
    max-width: 800px;
    margin: 0 auto;
    line-height: 1.6;
    font-size: 1.1rem;
}
</style>
</head>
<body>

<div class="loading" id="loading">Loading experience...</div>

<section class="cinematic-section" id="cinematic-section">
    <div class="cinematic-viewport" id="cinematic-viewport">
        <div class="image-container">
            <img src="https://media.sellfy.store/images/PXXhbh0L/El3m/soldier_before.jpg" alt="Before" id="before-img">
            <img src="https://media.sellfy.store/images/PXXhbh0L/79n3/soldier_after.jpg" class="after-image" alt="After" id="after-img">
        </div>
        
        <div class="cinematic-text" id="cinematic-text">
            <p>Scroll to reveal the transformation</p>
        </div>
    </div>
    
    <div class="progress-bar">
        <div class="progress-fill" id="progress-fill"></div>
    </div>
    
    <div class="scroll-hint" id="scroll-hint">
        <span>Scroll down</span>
        <div class="scroll-arrow"></div>
    </div>
</section>

<section class="content-after">
    <h3>Continue Your Journey</h3>
    <p>This is where your regular content continues. The cinematic reveal above creates an engaging entry point that naturally leads users into your main content. You can add more sections, products, or information here.</p>
</section>

<script>
(function() {
    'use strict';
    
    let isLoaded = false;
    let cinematicSection = null;
    let cinematicViewport = null;
    let afterImage = null;
    let progressFill = null;
    let scrollHint = null;
    let cinematicText = null;
    let cinematicTextP = null;
    let isActive = false;
    
    // Throttle function for performance
    function throttle(func, limit) {
        let inThrottle;
        return function() {
            const args = arguments;
            const context = this;
            if (!inThrottle) {
                func.apply(context, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        }
    }
    
    // Initialize the cinematic experience
    function initializeCinematic() {
        const beforeImg = document.getElementById('before-img');
        const afterImg = document.getElementById('after-img');
        let loadedCount = 0;
        
        function imageLoaded() {
            loadedCount++;
            if (loadedCount === 2) {
                document.getElementById('loading').style.display = 'none';
                
                // Get DOM elements
                cinematicSection = document.getElementById('cinematic-section');
                cinematicViewport = document.getElementById('cinematic-viewport');
                afterImage = document.getElementById('after-img');
                progressFill = document.getElementById('progress-fill');
                scrollHint = document.getElementById('scroll-hint');
                cinematicText = document.getElementById('cinematic-text');
                cinematicTextP = cinematicText.querySelector('p');
                
                isLoaded = true;
                setupScrollHandler();
                
                // Hide scroll hint after 5 seconds
                setTimeout(() => {
                    if (scrollHint) scrollHint.classList.add('fade-out');
                }, 5000);
            }
        }
        
        beforeImg.onload = imageLoaded;
        afterImg.onload = imageLoaded;
        
        // Handle already loaded images
        if (beforeImg.complete) imageLoaded();
        if (afterImg.complete) imageLoaded();
    }
    
    // Update text animation smoothly based on scroll progress
    function updateTextAnimation(scrollProgress) {
        if (!cinematicTextP) return;
        
        // Create smooth curves for different effects
        const textScale = 1 + (scrollProgress * 1.5); // Scale from 1 to 2.5
        const textOpacity = Math.max(0, 0.9 - (scrollProgress * 1.2)); // Fade from 0.9 to 0
        const textBlur = scrollProgress * 4; // Blur from 0 to 4px
        
        // Apply the transformations directly for smooth animation
        cinematicTextP.style.transform = `scale(${textScale})`;
        cinematicTextP.style.opacity = textOpacity;
        cinematicTextP.style.filter = `blur(${textBlur}px)`;
    }
    
    // Setup scroll-driven animation
    function setupScrollHandler() {
        const handleScroll = throttle(() => {
            if (!isLoaded) return;
            
            const rect = cinematicSection.getBoundingClientRect();
            const windowHeight = window.innerHeight;
            const sectionHeight = cinematicSection.offsetHeight;
            
            // Check if section is in viewport
            const isInViewport = rect.top < windowHeight && rect.bottom > 0;
            
            if (isInViewport) {
                if (!isActive) {
                    isActive = true;
                    cinematicSection.classList.add('active');
                }
                
                // Calculate progress (0 to 1)
                const scrollProgress = Math.max(0, Math.min(1, -rect.top / (sectionHeight - windowHeight)));
                
                // Update reveal effect
                const revealPercent = scrollProgress * 100;
                afterImage.style.clipPath = `inset(0 0 0 ${100 - revealPercent}%)`;
                
                // Update progress bar
                progressFill.style.width = `${revealPercent}%`;
                
                // Add some easing for smoother animation
                const easedProgress = easeOutCubic(scrollProgress);
                
                // Cinematic zoom effect - synchronized with text
                const scale = 1 + (easedProgress * 0.05); // Subtle zoom from 1 to 1.05
                cinematicViewport.style.transform = `scale(${scale})`;
                
                // Update text animation - perfectly synchronized
                updateTextAnimation(scrollProgress);
                
            } else {
                if (isActive && rect.bottom < 0) {
                    // Section has passed, ensure it's fully revealed
                    afterImage.style.clipPath = `inset(0 0 0 0%)`;
                    progressFill.style.width = '100%';
                    if (cinematicTextP) {
                        cinematicTextP.style.transform = 'scale(2.5)';
                        cinematicTextP.style.opacity = '0';
                        cinematicTextP.style.filter = 'blur(4px)';
                    }
                } else if (rect.top > windowHeight) {
                    // Section hasn't been reached yet, reset
                    isActive = false;
                    cinematicSection.classList.remove('active');
                    afterImage.style.clipPath = `inset(0 0 0 100%)`;
                    progressFill.style.width = '0%';
                    cinematicViewport.style.transform = 'scale(1)';
                    if (cinematicTextP) {
                        cinematicTextP.style.transform = 'scale(1)';
                        cinematicTextP.style.opacity = '0.9';
                        cinematicTextP.style.filter = 'blur(0px)';
                    }
                }
            }
        }, 16); // ~60fps
        
        window.addEventListener('scroll', handleScroll);
        
        // Initial call
        handleScroll();
    }
    
    // Easing function for smoother animation
    function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
    }
    
    // Enhanced mobile touch handling
    function setupMobileInteractions() {
        if ('ontouchstart' in window) {
            let startY = 0;
            let isScrolling = false;
            
            cinematicViewport.addEventListener('touchstart', (e) => {
                startY = e.touches[0].clientY;
                isScrolling = false;
            });
            
            cinematicViewport.addEventListener('touchmove', (e) => {
                if (!isScrolling) {
                    const currentY = e.touches[0].clientY;
                    const deltaY = startY - currentY;
                    
                    if (Math.abs(deltaY) > 10) {
                        isScrolling = true;
                    }
                }
            });
        }
    }
    
    // Performance optimization: Pause animations when not visible
    function setupVisibilityHandler() {
        if ('IntersectionObserver' in window) {
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        // Resume animations
                        document.body.style.willChange = 'scroll-position';
                    } else {
                        // Pause animations
                        document.body.style.willChange = 'auto';
                    }
                });
            });
            
            observer.observe(cinematicSection || document.body);
        }
    }
    
    // Initialize everything
    function init() {
        initializeCinematic();
        setupMobileInteractions();
        setupVisibilityHandler();
        
        // Preload images for better performance
        const link1 = document.createElement('link');
        link1.rel = 'preload';
        link1.as = 'image';
        link1.href = 'https://media.sellfy.store/images/PXXhbh0L/El3m/soldier_before.jpg';
        
        const link2 = document.createElement('link');
        link2.rel = 'preload';
        link2.as = 'image';
        link2.href = 'https://media.sellfy.store/images/PXXhbh0L/79n3/soldier_after.jpg';
        
        document.head.appendChild(link1);
        document.head.appendChild(link2);
    }
    
    // Start when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
    
})();
</script>

</body>
</html>
